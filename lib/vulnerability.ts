/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Contextual, subscription } from "@atomist/skill";

import { mapSeverity } from "./scan";
import { TrivyReport } from "./types";

export type Vulnerability = {
	sourceId: string;
	severity: subscription.datalog.DockerImageVulnerabilitySeverity;
	cvssScore: string;
	fixAvailable: boolean;
};

export type Vulnerabilities = {
	vulnerabilities: Vulnerability[];
	discovery: { status: string; source: string };
};

async function retrieveVulnerabilities(
	digest: string,
	ctx: Contextual<any, any>,
): Promise<Vulnerabilities> {
	const query = `[:find
 (pull
  ?image
  [:schema/entity-type
   {(:analysis.discovery/_image :as :analysis:discovery/discovery) [:analysis.discovery/status
                                                                    :analysis.discovery/source]}
   {:docker.analysis/vulnerabilities [:vulnerability.cve/source-id
                                      :vulnerability.cve/severity
                                      :vulnerability.cve/cvss-score
                                      :vulnerability.cve/fix-available]}])
 :in
 $
 $before-db
 %
 :where
 [?image :docker.image/digest ?digest]
 [?analysis :analysis.discovery/image ?image]
 [?analysis :analysis.discovery/source :analysis.discovery.source/TRIVY]]`;

	const vuls = await ctx.datalog.query<
		{ image: Vulnerabilities },
		{ digest: string }
	>(query, { digest });
	return {
		vulnerabilities: (vuls[0] as any)?.image?.vulnerabilities,
		discovery: (vuls[0] as any)?.image?.discovery?.[0],
	};
}

export function vulnerabilitiesEqual(
	vuls: TrivyReport[0]["Vulnerabilities"] = [],
	baseline: Vulnerability[] = [],
): boolean {
	if (
		vuls.some(v => !baseline.some(b => b.sourceId === v.VulnerabilityID)) ||
		baseline.some(b => !vuls.some(v => b.sourceId === v.VulnerabilityID))
	) {
		return false;
	}
	// Check that severity and cvssScore has not changed
	if (
		vuls.some(v => {
			const b = baseline.find(b => v.VulnerabilityID === b.sourceId);
			const score =
				v.CVSS?.nvd?.V3Score?.toString() ||
				v.CVSS?.nvd?.V2Score?.toString();
			if (b.cvssScore?.toString() !== score) {
				return true;
			}
			if (mapSeverity(v.Severity) !== b.severity) {
				return true;
			}
			return false;
		})
	) {
		return false;
	}
	return true;
}

export async function vulnerabilitiesChanged(
	digest: string,
	vuls: TrivyReport[0]["Vulnerabilities"],
	ctx: Contextual<any, any>,
): Promise<boolean> {
	const baseline = await retrieveVulnerabilities(digest, ctx);
	return !vulnerabilitiesEqual(vuls, baseline.vulnerabilities);
}
