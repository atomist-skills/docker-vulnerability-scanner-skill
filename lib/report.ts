/*
 * Copyright © 2020 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as _ from "lodash";

export type TrivyReport = Array<{
	Target: string;
	Type: string;
	Vulnerabilities: Array<{
		VulnerabilityID: string;
		PkgName: string;
		InstalledVersion: string;
		FixedVersion?: string;
		Title?: string;
		Description: string;
		Severity: "UNKNOWN" | "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
		PublishedDate: string;
		LastModifiedDate: string;
		CVSS: {
			nvd: {
				V3Vector: string;
				V3Score: string;
			};
		};
	}>;
}>;

export interface ReportAggregates {
	critical: number;
	high: number;
	medium: number;
	low: number;
	unknown: number;
}

export function aggregate(output: string): ReportAggregates {
	const report: TrivyReport = JSON.parse(output);
	const countFn = (severity: string) => {
		const vuls = [];
		report
			.filter(r => r.Vulnerabilities)
			.forEach(r =>
				r.Vulnerabilities.filter(
					v => v.Severity.toLowerCase() === severity.toLowerCase(),
				).forEach(v => vuls.push(v.VulnerabilityID)),
			);
		return _.uniq(vuls).length;
	};
	return {
		critical: countFn("critical"),
		high: countFn("high"),
		medium: countFn("medium"),
		low: countFn("low"),
		unknown: countFn("unknown"),
	};
}

export function format(output: string): string {
	const report: TrivyReport = JSON.parse(output);
	let data = "";
	for (const typeReport of report.filter(r => r.Vulnerabilities)) {
		data = `${data}

--- 

Scanning \`${typeReport.Target}\` found the following ${
			typeReport.Vulnerabilities.length === 1
				? "vulnerable package"
				: `${typeReport.Vulnerabilities.length} vulnerable packages`
		}:`;

		const packages = _.groupBy(
			_.orderBy(
				typeReport.Vulnerabilities,
				[
					v => {
						switch (v.Severity) {
							case "CRITICAL":
								return 0;
							case "HIGH":
								return 1;
							case "MEDIUM":
								return 2;
							case "LOW":
								return 3;
							default:
								return 4;
						}
					},
					"PublishedDate",
				],
				["asc", "desc"],
			),
			"PkgName",
		);
		_.forEach(packages, (v, k) => {
			const entry = `

### ${k}

${v
	.map(
		vul =>
			`<details><summary><a href="https://nvd.nist.gov/vuln/detail/${
				vul.VulnerabilityID
			}">${
				vul.VulnerabilityID
			}</a> · <i>${vul.Severity.toLowerCase()}</i> · <code>${
				vul.InstalledVersion
			}</code>${
				vul.FixedVersion
					? ` · fixed in <code>${vul.FixedVersion}</code>`
					: ""
			}</summary>${vul.Title ? `<h4>Title</h4>\n${vul.Title}\n` : ""}${
				vul.Description ? `<h4>Details</h4> \n${vul.Description}` : ""
			}

${
	vul.CVSS?.nvd
		? `<h4>CVSS</h4>
<code>${vul.CVSS.nvd.V3Vector}</code> · Score: <code>${vul.CVSS.nvd.V3Score}</code>`
		: ""
}<hr /></details>`,
	)
	.join("\n")}`;
			data = `${data}${entry}`;
		});
	}

	return data;
}

export function formatAggregates(
	vul: ReportAggregates,
): { msg: string; count: number } {
	const parts = [];
	let count;
	if (vul.critical > 0) {
		parts.push(`${vul.critical} critical`);
		count += vul.critical;
	}
	if (vul.high > 0) {
		parts.push(`${vul.high} high`);
		count += vul.high;
	}
	if (vul.medium > 0) {
		parts.push(`${vul.medium} medium`);
		count += vul.medium;
	}
	if (vul.low > 0) {
		parts.push(`${vul.low} low`);
		count += vul.low;
	}
	if (vul.unknown > 0) {
		parts.push(`${vul.unknown} unknown`);
		count += vul.unknown;
	}
	return {
		msg: parts.join(", ").replace(/, ([^,]*)$/, " and $1"),
		count,
	};
}

export function diffAggregates(
	before: ReportAggregates,
	after: ReportAggregates,
): ReportAggregates {
	return {
		critical: before.critical - after.critical,
		high: before.high - after.high,
		medium: before.medium - after.medium,
		low: before.low - after.low,
		unknown: before.unknown - after.unknown,
	};
}

export enum DiffQuality {
	Improved,
	NoChange,
	Decline,
}

export function qualifyDiff(diff: ReportAggregates): DiffQuality {
	if (!_.some(diff, v => v !== 0)) {
		return DiffQuality.NoChange;
	} else if (!_.some(diff, v => v < 0)) {
		return DiffQuality.Improved;
	} else {
		return DiffQuality.Decline;
	}
}

export function formatAggregateDiffs(
	before: ReportAggregates,
	after: ReportAggregates,
): { msg: string; count: number } {
	const parts = [];
	let count;
	if (before.critical > 0 || after.critical > 0) {
		parts.push(
			`${after.critical} (${after.critical > before.critical ? "+" : ""}${
				after.critical === before.critical ? "±" : ""
			}${after.critical - before.critical}) critical`,
		);
		count += after.critical;
	}
	if (before.high > 0 || after.high > 0) {
		parts.push(
			`${after.high} (${after.high > before.high ? "+" : ""}${
				after.high === before.high ? "±" : ""
			}${after.high - before.high}) high`,
		);
		count += after.high;
	}
	if (before.medium > 0 || after.medium > 0) {
		parts.push(
			`${after.medium} (${after.medium > before.medium ? "+" : ""}${
				after.medium === before.medium ? "±" : ""
			}${after.medium - before.medium}) medium`,
		);
		count += after.medium;
	}
	if (before.low > 0 || after.low > 0) {
		parts.push(
			`${after.low} (${after.low > before.low ? "+" : ""}${
				after.low === before.low ? "±" : ""
			}${after.low - before.low}) low`,
		);
		count += after.low;
	}
	if (before.unknown > 0 || after.unknown > 0) {
		parts.push(
			`${after.unknown} (${after.unknown > before.unknown ? "+" : ""}${
				after.unknown === before.unknown ? "±" : ""
			}${after.unknown - before.unknown}) unknown`,
		);
		count += after.unknown;
	}
	return {
		msg: `${parts.join(", ").replace(/, ([^,]*)$/, " and $1")}`,
		count,
	};
}

export function formatDiffs(before: TrivyReport, after: TrivyReport): string {
	const differ = (b: TrivyReport, a: TrivyReport, severity: string) => {
		const beforeVuls = _.flattenDeep(
			before
				.filter(b => b.Vulnerabilities)
				.map(b =>
					b.Vulnerabilities.filter(
						v => v.Severity.toLowerCase() === severity,
					).map(v => ({
						id: v.VulnerabilityID,
						package: v.PkgName,
						severity,
					})),
				),
		);
		const afterVuls = _.flattenDeep(
			after
				.filter(b => b.Vulnerabilities)
				.map(b =>
					b.Vulnerabilities.filter(
						v => v.Severity.toLowerCase() === severity,
					).map(v => ({
						id: v.VulnerabilityID,
						package: v.PkgName,
						severity,
					})),
				),
		);

		// Find additions
		const additions = afterVuls.filter(
			a => !beforeVuls.some(b => b.id === a.id),
		);
		// Find removals
		const removals = beforeVuls
			.filter(a => !afterVuls.some(b => b.id === a.id))
			.filter(a => !additions.filter(b => b.id === a.id));

		return {
			additions,
			removals,
		};
	};

	const diffs = [
		differ(before, after, "critical"),
		differ(before, after, "high"),
		differ(before, after, "medium"),
		differ(before, after, "low"),
		differ(before, after, "unknown"),
	];

	let data = "";
	if (diffs.some(d => d.additions.length > 0)) {
		data = `New or updated CVEs: 
${_.map(
	_.groupBy(_.flattenDeep(diffs.map(d => d.additions)), "id"),
	(v, k) =>
		` * ${k} · _${v[0].severity.toLowerCase()}_ · ${v
			.map(p => `\`${p.package}\``)
			.join(", ")}`,
).join("\n")}

`;
	}
	if (diffs.some(d => d.removals.length > 0)) {
		data = `${data}Fixed or removed CVEs: 
${_.map(
	_.groupBy(_.flattenDeep(diffs.map(d => d.removals)), "id"),
	(v, k) =>
		` * ${k} · _${v[0].severity.toLowerCase()}_ · ${v
			.map(p => `\`${p.package}\``)
			.join(", ")}`,
).join("\n")}`;
	}
	if (data.length === 0) {
		data = "No changes to CVEs detected";
	}
	return data;
}
