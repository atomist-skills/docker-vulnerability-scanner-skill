/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
	childProcess,
	Contextual,
	datalog,
	EventContext,
	HandlerStatus,
	log,
	repository,
	secret,
	state,
	status,
	subscription,
	tmpFs,
} from "@atomist/skill";
import * as fs from "fs-extra";
import * as _ from "lodash";
import * as os from "os";
import * as path from "path";

import { getOAuthAccessToken } from "./auth";
import { Configuration } from "./configuration";
import { CveItem, Result } from "./cve_types";
import {
	ExtendedDockerRegistry,
	PullableDockerImage,
	TrivyReport,
} from "./types";

export async function startScanning(
	ctx: EventContext<any, Configuration>,
	image: Pick<PullableDockerImage, "digest">,
): Promise<void> {
	// Signal start of scanning
	await ctx.datalog.transact([
		datalog.entity("docker/image", "$image", {
			digest: image.digest,
		}),
		datalog.entity("analysis/discovery", {
			image: "$image",
			status: ":analysis.discovery.status/SCANNING",
			source: ":analysis.discovery.source/TRIVY",
			lastUpdated: new Date(),
		}),
	]);
}

export async function scanImage(
	ctx: EventContext<any, Configuration>,
	image: Omit<subscription.datalog.DockerImage, "labels" | "tags">,
	registries: ExtendedDockerRegistry[],
	commit?: subscription.datalog.Commit,
): Promise<HandlerStatus> {
	const digest = image.digest;

	const project = await ctx.project.load(
		repository.gitHub({
			credential: undefined,
			owner: undefined,
			repo: undefined,
		}),
		process.env.ATOMIST_HOME || os.tmpdir(),
	);

	const imageName =
		image.repository.host !== "hub.docker.com"
			? `${image.repository.host}/${image.repository.name}`
			: image.repository.name;

	let scanned = false;

	for (const registry of registries) {
		const env = { ...process.env };

		// Trivy needs a GITHUB_TOKEN to not get rate-limited downloading the vul db
		if (commit?.repo?.org?.installationToken) {
			env.GITHUB_TOKEN = commit.repo.org.installationToken;
		} else {
			const cred = await ctx.credential.resolve(secret.gitHubAppToken());
			env.GITHUB_TOKEN = cred?.token;
		}

		if (registry) {
			switch (registry.type) {
				case subscription.datalog.DockerRegistryType.Gcr:
					if (
						registry.serviceAccount ||
						ctx.workspaceId === "T7GMF5USG"
					) {
						env.GOOGLE_APPLICATION_CREDENTIALS = "";
						env.TRIVY_USERNAME = "oauth2accesstoken";
						env.TRIVY_PASSWORD = await getOAuthAccessToken(
							registry.serviceAccount,
							ctx,
						);
					} else {
						env.TRIVY_USERNAME = "";
						env.GOOGLE_APPLICATION_CREDENTIALS =
							await tmpFs.createFile(ctx, {
								content: registry.secret,
							});
					}
					break;
				default:
					env.TRIVY_USERNAME = registry.username;
					env.TRIVY_PASSWORD = registry.secret;
					break;
			}
		}

		const outputFile = await tmpFs.createFilePath(ctx, `${digest}.json`);

		const cmd = "trivy";
		const args = [
			"--cache-dir",
			await tmpFs.createDir(ctx),
			"image",
			"--exit-code",
			"0",
		];

		args.push("--format", "json");
		// args.push("--vuln-type", "os");
		args.push("--output", outputFile, "--no-progress");
		args.push(`${imageName}@${image.digest}`);

		log.debug(JSON.stringify(env));

		const result = await project.spawn(cmd, args, { env });

		if (result.status === 0) {
			let report: TrivyReport;
			try {
				report = JSON.parse((await fs.readFile(outputFile)).toString());
			} catch (e) {
				return status
					.failure(
						`Failed to scan image \`${imageName}@${image.digest}\``,
					)
					.hidden();
			}

			if (!report) {
				continue;
			}

			scanned = true;

			const vuls = _.values(
				_.groupBy(
					_.flattenDeep(
						report
							.filter(r => r.Vulnerabilities)
							.map(r => r.Vulnerabilities),
					),
					"VulnerabilityID",
				),
			);

			// Enrich CVE details
			for (const vul of _.flattenDeep(vuls || [])) {
				const cveDetails = await retrieveCveDetails(
					ctx,
					vul.VulnerabilityID,
				);
				if (cveDetails) {
					vul.Severity = (cveDetails.impact?.baseMetricV3?.cvssV3
						?.baseSeverity ||
						cveDetails.impact?.baseMetricV2?.severity ||
						vul.Severity) as any;
					_.set(
						vul,
						"CVSS.nvd.V3Score",
						cveDetails.impact?.baseMetricV3?.cvssV3?.baseScore ||
							vul.CVSS?.nvd?.V3Score,
					);
					_.set(
						vul,
						"CVSS.nvd.V2Score",
						cveDetails.impact?.baseMetricV2?.cvssV2?.baseScore ||
							vul.CVSS?.nvd?.V2Score,
					);
				}
			}

			log.info(
				`Vulnerabilities ${image.digest}: ${_.flattenDeep(vuls || [])
					.map(v => `${v.VulnerabilityID} - ${v.Severity}`)
					.join(", ")}`,
			);

			const vulsChunks = _.chunk(vuls, 25);

			for (let i = 0; i < vulsChunks.length; i++) {
				const vulChunk = vulsChunks[i];
				const entities = [
					..._.map(
						_.groupBy(_.flatten(vulChunk), "Layer.Digest"),
						(v, k) =>
							datalog.entity("docker.image/blob", {
								digest: k,
								vulnerabilities: {
									add: _.uniq(
										v.map(
											vul =>
												`$vulnerability-${vul.VulnerabilityID}`,
										),
									),
								},
							}),
					),
					..._.uniqBy(
						_.flatten(
							vulChunk.map(vu =>
								vu
									.filter(v => v.InstalledVersion)
									.map(v =>
										datalog.entity(
											"docker.analysis/package",
											`$package-${v.VulnerabilityID}-${v.PkgName}-${v.InstalledVersion}`,
											{
												name: v.PkgName,
												version: v.InstalledVersion,
											},
										),
									),
							),
						),
						"schema/entity",
					),
					..._.uniqBy(
						_.flatten(
							vulChunk.map(vu =>
								vu
									.filter(v => v.FixedVersion)
									.map(v =>
										datalog.entity(
											"docker.analysis/package",
											`$package-fix-${v.VulnerabilityID}-${v.PkgName}-${v.FixedVersion}`,
											{
												name: v.PkgName,
												version: v.FixedVersion,
											},
										),
									),
							),
						),
						"schema/entity",
					),
					...vulChunk.map(vu => {
						const v = vu[0];

						const affected = _.uniq(
							vu
								.filter(vup => vup.InstalledVersion)
								.map(
									vup =>
										`$package-${v.VulnerabilityID}-${vup.PkgName}-${vup.InstalledVersion}`,
								),
						);
						const fixed = _.uniq(
							vu
								.filter(vup => vup.FixedVersion)
								.map(
									vup =>
										`$package-fix-${v.VulnerabilityID}-${vup.PkgName}-${vup.FixedVersion}`,
								),
						);

						const cve = datalog.entity(
							"vulnerability/cve",
							`$vulnerability-${v.VulnerabilityID}`,
							{
								"sourceId": v.VulnerabilityID,
								"severity": `:vulnerability.cve.severity/${mapSeverity(
									v.Severity,
								)}`,
								"effectiveSeverity": `:vulnerability.cve.severity/${mapSeverity(
									v.Severity,
								)}`,
								"fixAvailable": v.FixedVersion !== undefined,
								"title": v.Title,
								"cvssScore":
									v.CVSS?.nvd?.V3Score?.toString() ||
									v.CVSS?.nvd?.V2Score?.toString(),
								"created": v.PublishedDate
									? new Date(v.PublishedDate)
									: undefined,
								"lastUpdated": v.LastModifiedDate
									? new Date(v.LastModifiedDate)
									: undefined,
								"docker.analysis/affected":
									affected.length > 0 ? affected : undefined,
								"docker.analysis/fixed":
									fixed.length > 0 ? fixed : undefined,
							},
						);
						return cve;
					}),
					datalog.entity("docker/image", "$image", {
						"digest": digest,
						"docker.analysis/vulnerabilities": {
							[i === 0 ? "set" : "add"]: _.uniq(
								vulChunk.map(
									v =>
										`$vulnerability-${v[0].VulnerabilityID}`,
								),
							),
						} as any,
						"docker.analysis/affected": {
							[i === 0 ? "set" : "add"]: _.uniq(
								_.flatten(
									vulChunk.map(v =>
										v
											.filter(v => v.InstalledVersion)
											.map(
												vup =>
													`$package-${vup.VulnerabilityID}-${vup.PkgName}-${vup.InstalledVersion}`,
											),
									),
								),
							),
						} as any,
						"docker.analysis/fixed": {
							[i === 0 ? "set" : "add"]: _.uniq(
								_.flatten(
									vulChunk.map(v =>
										v
											.filter(v => v.FixedVersion)
											.map(
												vup =>
													`$package-fix-${vup.VulnerabilityID}-${vup.PkgName}-${vup.FixedVersion}`,
											),
									),
								),
							),
						} as any,
					}),
				];
				await ctx.datalog.transact(entities);
			}

			const entities = [];

			// transact the vulnerability/report
			await ctx.datalog.transact([
				datalog.entity("docker/image", "$image", {
					digest,
				}),
				datalog.entity("vulnerability/report", {
					image: "$image",
					lastUpdated: new Date(),
					critical: countCve(report, "CRITICAL"),
					high: countCve(report, "HIGH"),
					medium: countCve(report, "MEDIUM"),
					low: countCve(report, "LOW"),
					unspecified: countCve(report, "UNKNOWN"),
				}),
			]);

			await ctx.datalog.transact([
				datalog.entity("docker/image", "$image", {
					digest,
				}),
				datalog.entity("analysis/discovery", "$discovery", {
					image: "$image",
					status: ":analysis.discovery.status/FINISHED_SUCCESS",
					source: ":analysis.discovery.source/TRIVY",
					lastUpdated: new Date(),
				}),
				...entities,
			]);

			return status.success(
				`${vuls.length} ${
					vuls.length === 1 ? "vulnerability" : "vulnerabilities"
				} found on \`${imageName}@${image.digest}\``,
			);
		}
	}

	await ctx.datalog.transact([
		datalog.entity("docker/image", "$image", {
			digest,
		}),
		datalog.entity("analysis/discovery", "$discovery", {
			image: "$image",
			status: `:analysis.discovery.status/${
				scanned ? "FINISHED_SUCCESS" : "FINISHED_FAILED"
			}`,
			source: ":analysis.discovery.source/TRIVY",
			lastUpdated: new Date(),
		}),
	]);

	if (scanned) {
		return status.success(
			`No vulnerabilities found on \`${imageName}@${image.digest}\``,
		);
	} else {
		return status.failure(
			`Failed to scan \`${imageName}@${image.digest}\``,
		);
	}
}

function mapSeverity(severity: string): string {
	switch (severity) {
		case "UNKNOWN":
			return "SEVERITY_UNSPECIFIED";
		default:
			return severity;
	}
}

function countCve(
	report: TrivyReport,
	severity: TrivyReport[0]["Vulnerabilities"][0]["Severity"],
): number {
	const vuls = _.flattenDeep(
		report
			.filter(r => r.Vulnerabilities)
			.map(r => r.Vulnerabilities.filter(v => v.Severity === severity)),
	);
	return _.uniqBy(vuls, "VulnerabilityID").length;
}

export const retrieveCveDetails = state.cachify(doRetrieveCveDetails, {
	ttl: 1000 * 60 * 60 * 24 * 7, // cache for a week
});

export async function doRetrieveCveDetails(
	ctx: Contextual<any, any>,
	cveId: string,
): Promise<CveItem> {
	try {
		const year = cveId.split("-")[1];
		if (!cveId.startsWith("CVE") || year.length !== 4 || year[0] !== "2") {
			return undefined;
		}
		const cveArchive = await downloadCveArchive(year, ctx);
		if (!cveArchive) {
			return undefined;
		}
		return cveArchive.CVE_Items.find(c => c.cve.CVE_data_meta.ID === cveId);
	} catch (e) {
		log.warn(`Failed to retrieve CVE details from nist.gov: ${e.message}`);
		return undefined;
	}
}

const downloadCveArchive = _.memoize(doDownloadCveArchive);

async function doDownloadCveArchive(
	year: string,
	ctx: Contextual<any, any>,
): Promise<Result> {
	try {
		const fileName = `nvdcve-1.1-${year}.json`;
		const url = `https://nvd.nist.gov/feeds/json/cve/1.1/${fileName}.zip`;
		const zipDir = await tmpFs.createDir(ctx);
		const zipFile = path.join(zipDir, `${fileName}.zip`);
		const response = await ctx.http.request(url, { method: "GET" });
		const stream = fs.createWriteStream(zipFile);
		await new Promise((resolve, reject) => {
			response.body.pipe(stream);
			response.body.on("error", err => {
				reject(err);
			});
			stream.on("finish", function () {
				resolve(zipFile);
			});
		});
		await childProcess.spawnPromise("unzip", ["-d", zipDir, zipFile]);
		return fs.readJson(path.join(zipDir, fileName));
	} catch (e) {
		log.warn(`Failed to retrieve CVE archive from nist.gov: ${e.message}`);
		return undefined;
	}
}
